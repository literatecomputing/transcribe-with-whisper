#!/usr/bin/env bash
set -euo pipefail

# bin/new-release
# Usage:
#   bin/new-release            # show latest release
#   bin/new-release 1.2.3     # create and push tag v1.2.3 and create a GitHub Release
#
# Requirements: git, gh (GitHub CLI)

print_usage() {
  cat <<EOF
Usage:
  $0               Show latest GitHub release for the current repo
  $0 <version>     Create an annotated tag (prefixed with v if not provided), push it, and create a GitHub Release

Examples:
  $0
  $0 0.7.8
  $0 v0.7.8
EOF
}

ensure_command() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Required command not found: $1" >&2
    exit 1
  fi
}

ensure_command git
ensure_command gh

if [ "$#" -eq 0 ]; then
  # Show latest release (if any)
  # Use gh to list releases and then view the most recent one
  if gh release list --limit 1 >/dev/null 2>&1; then
    TAG_NAME=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
    echo "Latest release: $TAG_NAME"
    gh release view "$TAG_NAME" --json tagName,name,body,createdAt,publishedAt,url --jq '{tag: .tagName, name: .name, url: .url, published: .publishedAt, created: .createdAt, notes: .body}'
    exit 0

  fi
fi

if [ "$#" -ne 1 ]; then
  print_usage
  exit 2
fi

RAW_VER="$1"
# normalize to start with 'v'
if [[ "$RAW_VER" == v* ]]; then
  TAG="$RAW_VER"
else
  TAG="v$RAW_VER"
fi

echo "Preparing release for tag: $TAG"

# ensure working tree is clean
if ! git diff --no-ext-diff --quiet --exit-code || ! git diff --no-ext-diff --quiet --exit-code --cached; then
  echo "Working tree has changes. Please commit or stash them before creating a release." >&2
  exit 1
fi

# check local tag
if git rev-parse "$TAG" >/dev/null 2>&1; then
  echo "Tag $TAG already exists locally. Aborting." >&2
  exit 1
fi

# check remote tag
if git ls-remote --tags origin --refs "refs/tags/$TAG" | grep -q "refs/tags/$TAG"; then
  echo "Tag $TAG already exists on remote. Aborting." >&2
  exit 1
fi

# Normalize version without leading 'v' for files that contain bare versions
if [[ "$RAW_VER" == v* ]]; then
  VER_NO_V="${RAW_VER#v}"
else
  VER_NO_V="$RAW_VER"
fi

echo "Updating version in setup.py to $VER_NO_V"
# Update the first occurrence of version= in setup.py. Exit if not found.
if ! grep -qE "version\s*=\s*['\"][0-9]+\.[0-9]+\.[0-9]+['\"]" setup.py; then
  echo 'Could not find version= in setup.py' >&2
  exit 1
fi
# Replace only the first occurrence of version=... with the new version
sed -E -i "0,/version\s*=\s*['\"][^'\"]+['\"]/s//version=\"${VER_NO_V}\"/" setup.py
echo 'setup.py updated'

git add setup.py
git commit -m "Bump version to $VER_NO_V"

# Push the commit to the current branch so the tag points at a pushed commit
BRANCH=$(git rev-parse --abbrev-ref HEAD)
echo "Pushing commit to origin/$BRANCH"
git push origin "$BRANCH"

CURRENT_HEAD=$(git rev-parse --verify HEAD)

echo "Creating annotated tag $TAG for commit $CURRENT_HEAD"
git tag -a "$TAG" -m "Release $TAG"

echo "Pushing tag $TAG to origin"
git push origin "refs/tags/$TAG"

echo "Creating GitHub Release for $TAG"
# Create a release targeting the current HEAD, with a minimal note; users can edit the release on GitHub as desired
gh release create "$TAG" --title "Release $TAG" --notes "Automated release created by bin/new-release" --target "$CURRENT_HEAD"

echo "Release $TAG created successfully."

exit 0
